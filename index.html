<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Curling Draw Simulator — D3</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root {
    --bg: #0a0f14;
    --panel: #121821;
    --ink: #e6edf3;
    --muted: #9fb3c8;
    --accent: #4aa3ff;
    --accent2: #79d27f;
    --warn: #ff7b72;
  }
  body {
    margin: 0; background: var(--bg); color: var(--ink);
    font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
  }
  .wrap { display: grid; grid-template-columns: 1fr; gap: 12px; padding: 12px; }
  .panel {
    background: var(--panel); border-radius: 12px; padding: 12px; box-shadow: 0 6px 20px rgba(0,0,0,.25);
  }
  fieldset { border: 1px solid #223045; border-radius: 10px; margin: 0 0 10px 0; padding: 10px; }
  legend { color: var(--muted); padding: 0 6px; }
  label { display: grid; grid-template-columns: 1fr 100px; gap: 8px; align-items: baseline; margin: 6px 0; }
  input[type="number"] { width: 100%; box-sizing: border-box; padding: 4px 6px; border-radius: 6px; border: 1px solid #273449; background: #0e141b; color: var(--ink); }
  select { width: 100%; padding: 4px 6px; border-radius: 6px; border: 1px solid #273449; background: #0e141b; color: var(--ink); }
  .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .buttons { display: flex; gap: 8px; }
  button {
    background: var(--accent); color: #03264d; border: 0; padding: 8px 10px; border-radius: 10px; cursor: pointer; font-weight: 700;
  }
  button.secondary { background: #24344a; color: var(--ink); }
  button.warn { background: var(--warn); color: #4d0b05; }
  .small { color: var(--muted); font-size: 12px; }
  svg { width: 100%; height: 520px; display: block; background: #dfe9f2; border-radius: 12px; }
  .hog { stroke: #b00; stroke-width: 2; }
  .tee { stroke: #0b4; stroke-width: 2; }
  .house { fill: none; stroke-width: 2; }
  .sheet { fill: #cfe1ee; }
  .broom { stroke: var(--accent); fill: var(--accent); }
  .stone { fill: #444; stroke: #111; stroke-width: 1.5; }
  .path { fill: none; stroke: #1f2b38; stroke-width: 2; }
  .curl-label { fill: #0b2236; font-weight: 700; }
  .metric { display: grid; grid-template-columns: 1fr auto; gap: 6px; }
  .metric span.v { font-variant-numeric: tabular-nums; }
  
  /* Added styles for horizontal layout */
  .controls-panel {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 12px;
  }
  
  .metrics-container {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-top: 8px;
  }
  
  /* Make buttons better distributed */
  .buttons {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  
  /* Optional: make all fieldsets same height */
  fieldset {
    height: calc(100% - 20px);
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
  }
  
  /* Ensure sheet is the right height for the available width */
  svg {
    width: 100%;
    height: auto;
    aspect-ratio: 6.3 / 1; /* Approximate ratio of a curling sheet length/width */
  }
</style>
</head>
<body>
<div class="wrap">
  <!-- Sheet panel first (full width) -->
  <div class="panel">
    <svg id="rink"></svg>
  </div>
  
  <!-- Controls panel below -->
  <div class="panel controls-panel">
    <!-- First column - Shot parameters -->
    <fieldset>
      <legend>Shot</legend>
      <label>Initial speed V0 (m/s)
        <input id="V0" type="number" step="0.01" min="0.1" max="6" value="3.0">
      </label>
      <div class="row">
        <label>Spin |ω0| (rad/s)
          <input id="omega0" type="number" step="0.01" min="0" max="5" value="1.45">
        </label>
        <label>Turn
          <select id="turn"><option value="out">out (CW)</option><option value="in">in (CCW)</option></select>
        </label>
      </div>
      <div class="row">
        <label>ice speed
          <input id="mu0" type="number" step="0.0005" min="0.001" max="0.03" value="0.008">
        </label>
        <label>stone sharpness
          <input id="alpha" type="number" step="0.0005" min="0.0" max="0.1" value="0.014">
        </label>
      </div>
      <label>Sweep factor (×)
        <input id="sweep" type="number" step="0.01" min="0.5" max="1.5" value="1.0">
      </label>
    </fieldset>

    <fieldset>
      <legend>Advanced</legend>
      <div class="row">
        <label>segments
          <input id="segments" type="number" step="1" min="60" max="720" value="180">
        </label>
        <label>dt (s)
          <input id="dt" type="number" step="0.001" min="0.001" max="0.05" value="0.01">
        </label>
      </div>
      <div class="row">
        <label>t_max (s)
          <input id="tmax" type="number" step="1" min="5" max="120" value="60">
        </label>
        <label>r_band (m)
          <input id="rband" type="number" step="0.001" min="0.04" max="0.09" value="0.065">
        </label>
      </div>
      <label>R (rock radius, m)
        <input id="R" type="number" step="0.001" min="0.12" max="0.17" value="0.145">
      </label>
      <div class="small">Click on the sheet to place the skip’s broom. Rock won’t move until you press <b>Throw</b>.</div>
    </fieldset>

    <!-- Third column - Buttons and metrics -->
    <div>
      <div class="buttons">
        <button id="throwBtn">Throw</button>
        <button id="resetBtn" class="secondary">Reset</button>
        <button id="csvBtn" class="secondary">Export CSV</button>
        <button id="stopBtn" class="warn">Stop</button>
      </div>
      
      <hr style="border:0;border-top:1px solid #2a3a52; margin:10px 0;">
      
      <!-- Stone control buttons -->
      <fieldset>
        <legend>Stones</legend>
        <div class="buttons">
          <button id="addRedBtn" class="secondary" style="background:#e74c3c;color:#fff">Add Red</button>
          <button id="addYellowBtn" class="secondary" style="background:#f1c40f;color:#333">Add Yellow</button>
          <button id="removeStoneBtn" class="secondary">Remove Selected</button>
          <button id="clearStonesBtn" class="warn">Clear All</button>
        </div>
        <div class="small" style="margin-top:8px">Click a stone to select it for throwing or removing.</div>
      </fieldset>
      
      <hr style="border:0;border-top:1px solid #2a3a52; margin:10px 0;">
      <div class="metrics-container">
        <div class="metric"><span>Final x (m)</span><span class="v" id="mx"></span></div>
        <div class="metric"><span>Final curl y (m)</span><span class="v" id="my"></span></div>
        <div class="metric"><span>Total time (s)</span><span class="v" id="mt"></span></div>
        <div class="metric"><span>Hog→Hog time (s)</span><span class="v" id="mhh"></span></div>
      </div>
    </div>
  </div>
</div>

<script>
/*** Geometry (meters) ***/
const SHEET_W = 4.75;            // sheet width
const HALF_W = SHEET_W / 2;
const HOG_TO_HOG = 21.95;
const HOG_TO_TEE = 6.40;
const HOUSE_R12 = 1.829;         // 12 ft radius
const HOUSE_R8  = 1.219;         // 8 ft
const HOUSE_R4  = 0.610;         // 4 ft
const BUTTON_R  = 0.15;

// Visible x-range: from near hog (0) to a bit past far house
const XMIN = 0;
const XMAX = HOG_TO_HOG + HOG_TO_TEE + HOUSE_R12 + 1.3; // ~30 m
const TEE_X = HOG_TO_HOG + HOG_TO_TEE;
const FAR_HOG_X = HOG_TO_HOG;

/*** UI / SVG setup ***/
const svg = d3.select("#rink");
const W = svg.node().clientWidth;

// Calculate ideal height based on physical sheet proportions
const sheetRatio = SHEET_W / (XMAX - XMIN); // Width:Length ratio
const idealHeight = W * sheetRatio;

// Set SVG height directly
svg.style("height", idealHeight + "px");

const H = svg.node().clientHeight;
const M = {t:16, r:24, b:16, l:24};

// Calculate the pixels per meter based on the x-axis
const pixelsPerMeter = (W - M.l - M.r) / (XMAX - XMIN);
const totalSheetWidth = SHEET_W * pixelsPerMeter;
const yCenter = (H - M.t - M.b) / 2 + M.t;  // Center of available height

const xScale = d3.scaleLinear()
  .domain([XMIN, XMAX])
  .range([M.l, W - M.r]);

const yScale = d3.scaleLinear()
  .domain([-HALF_W, HALF_W])
  .range([yCenter + totalSheetWidth/2, yCenter - totalSheetWidth/2]);

// Sheet background
svg.append("rect")
  .attr("class", "sheet")
  .attr("x", xScale(XMIN)).attr("y", yScale(HALF_W))
  .attr("width", xScale(XMAX) - xScale(XMIN))
  .attr("height", yScale(-HALF_W) - yScale(HALF_W));

// Hog lines and tee line
svg.append("line").attr("class","hog")
  .attr("x1", xScale(0)).attr("y1", yScale(-HALF_W))
  .attr("x2", xScale(0)).attr("y2", yScale(HALF_W));
svg.append("line").attr("class","hog")
  .attr("x1", xScale(FAR_HOG_X)).attr("y1", yScale(-HALF_W))
  .attr("x2", xScale(FAR_HOG_X)).attr("y2", yScale(HALF_W));
svg.append("line").attr("class","tee")
  .attr("x1", xScale(TEE_X)).attr("y1", yScale(-HALF_W))
  .attr("x2", xScale(TEE_X)).attr("y2", yScale(HALF_W));

// House
const house = svg.append("g");
house.append("circle").attr("class","house").attr("stroke","#0b4")
  .attr("cx", xScale(TEE_X)).attr("cy", yScale(0)).attr("r", Math.abs(xScale(TEE_X+HOUSE_R12)-xScale(TEE_X)));
house.append("circle").attr("class","house").attr("stroke","#1765ff")
  .attr("cx", xScale(TEE_X)).attr("cy", yScale(0)).attr("r", Math.abs(xScale(TEE_X+HOUSE_R8)-xScale(TEE_X)));
house.append("circle").attr("class","house").attr("stroke","#c00")
  .attr("cx", xScale(TEE_X)).attr("cy", yScale(0)).attr("r", Math.abs(xScale(TEE_X+HOUSE_R4)-xScale(TEE_X)));
house.append("circle").attr("fill","#eee").attr("stroke","#333")
  .attr("cx", xScale(TEE_X)).attr("cy", yScale(0)).attr("r", Math.abs(xScale(TEE_X+BUTTON_R)-xScale(TEE_X)));

// Start location: near hog centerline
const start = { x: 0.2, y: 0 }; // 20 cm to right of near hog line

// Broom marker
const broom = svg.append("g").attr("class","broom");
let broomPos = { x: TEE_X, y: 0 }; // default on the button
broom.append("circle").attr("r", 6).attr("cx", xScale(broomPos.x)).attr("cy", yScale(broomPos.y));
broom.append("line").attr("x1", xScale(broomPos.x)).attr("y1", yScale(broomPos.y - 0.2))
  .attr("x2", xScale(broomPos.x)).attr("y2", yScale(broomPos.y + 0.2)).attr("stroke-width", 3).attr("stroke", "#4aa3ff");

// Path and stone
const pathG = svg.append("path").attr("class","path");
const stone = svg.append("circle").attr("class","stone").attr("r", 7)
  .attr("cx", xScale(start.x)).attr("cy", yScale(start.y));

// Click to place broom
svg.on("click", (ev) => {
  const p = d3.pointer(ev, svg.node());
  const x = xScale.invert(p[0]);
  const y = yScale.invert(p[1]);
  if (x < XMIN || x > XMAX || Math.abs(y) > HALF_W) return;
  broomPos = { x, y };
  broom.select("circle").attr("cx", xScale(x)).attr("cy", yScale(y));
  broom.select("line")
    .attr("x1", xScale(x)).attr("y1", yScale(y - 0.2))
    .attr("x2", xScale(x)).attr("y2", yScale(y + 0.2));
});

// UI getters
const V0     = () => +document.getElementById("V0").value;
const omega0 = () => +document.getElementById("omega0").value;
const turn   = () => document.getElementById("turn").value;
const mu0    = () => +document.getElementById("mu0").value;
const alpha  = () => +document.getElementById("alpha").value;
const sweep  = () => +document.getElementById("sweep").value;
const segments = () => +document.getElementById("segments").value;
const dt     = () => +document.getElementById("dt").value;
const tmax   = () => +document.getElementById("tmax").value;
const rband  = () => +document.getElementById("rband").value;
const Rrock  = () => +document.getElementById("R").value;

const mx = document.getElementById("mx");
const my = document.getElementById("my");
const mt = document.getElementById("mt");
const mhh = document.getElementById("mhh");

/*** Physics model (JS port with aim) ***/
class Params {
  constructor() {
    this.m = 19.0;    // kg
    this.g = 9.81;
    this.R = Rrock();
    this.rBand = rband();
    this.mu0 = mu0() * sweep();
    this.alpha = alpha();
    this.segments = segments();
    this.dt = dt();
    this.tMax = tmax();
    this.vStop = 0.01;
    this.wStop = 0.02;
    this.vEps = 1e-6;
    this.restitution = 0.8; // Coefficient of restitution for stone-stone collisions
  }
}
class State {
  constructor(t, x, y, vx, vy, w) { this.t=t; this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.w=w; }
}

// Stone class for tracking multiple stones
class Stone {
  constructor(id, position = {x: 0, y: 0}, velocity = {vx: 0, vy: 0}, omega = 0, team = 'red') {
    this.id = id;         // Unique identifier
    this.x = position.x;
    this.y = position.y;
    this.vx = velocity.vx;
    this.vy = velocity.vy;
    this.w = omega;       // Angular velocity
    this.team = team;     // 'red' or 'yellow'
    this.inPlay = true;   // Flag for stones in play
    this.t = 0;           // Time tracker
  }
  
  // Create a new state object from this stone
  toState() {
    return new State(this.t, this.x, this.y, this.vx, this.vy, this.w);
  }
  
  // Update stone from a state object
  fromState(state) {
    this.t = state.t;
    this.x = state.x;
    this.y = state.y;
    this.vx = state.vx;
    this.vy = state.vy;
    this.w = state.w;
  }
}

// Collection of all stones in play
const stones = [];
function unit(vx, vy, eps) {
  const s = Math.hypot(vx, vy);
  if (s < eps) return { ux: 0, uy: 0, s: eps };
  return { ux: vx / s, uy: vy / s, s };
}

// Collision detection between stones
function detectCollisions(stonesList, params) {
  const twoR = 2 * params.R;  // Diameter - minimum distance between stone centers
  
  for (let i = 0; i < stonesList.length; i++) {
    if (!stonesList[i].inPlay) continue;
    
    for (let j = i + 1; j < stonesList.length; j++) {
      if (!stonesList[j].inPlay) continue;
      
      // Calculate distance between stone centers
      const dx = stonesList[j].x - stonesList[i].x;
      const dy = stonesList[j].y - stonesList[i].y;
      const distance = Math.sqrt(dx*dx + dy*dy);
      
      // Check for collision
      if (distance < twoR) {
        // Stones are colliding - resolve collision
        resolveCollision(stonesList[i], stonesList[j], params);
      }
    }
  }
}

// Collision resolution using conservation of momentum
function resolveCollision(stone1, stone2, params) {
  // Unit vector along collision line
  const dx = stone2.x - stone1.x;
  const dy = stone2.y - stone1.y;
  const distance = Math.sqrt(dx*dx + dy*dy);
  
  // Normalize direction vector
  const nx = dx / distance;
  const ny = dy / distance;
  
  // Relative velocity
  const dvx = stone2.vx - stone1.vx;
  const dvy = stone2.vy - stone1.vy;
  
  // Project velocity onto collision normal
  const relativeVelocityAlongNormal = dvx * nx + dvy * ny;
  
  // Do not resolve if objects are moving away from each other
  if (relativeVelocityAlongNormal > 0) return;
  
  // Coefficient of restitution (1 = perfect elastic, < 1 = energy loss)
  const e = params.restitution;
  
  // Impulse scalar
  const j = -(1 + e) * relativeVelocityAlongNormal / 2; // Divide by 2 since both stones have equal mass
  
  // Apply impulse
  stone1.vx -= j * nx;
  stone1.vy -= j * ny;
  stone2.vx += j * nx;
  stone2.vy += j * ny;
  
  // Apply angular momentum changes - simplified model
  // Angular momentum change proportional to cross product of collision normal and impact point
  const crossFactor = 0.5; // Tuning parameter
  stone1.w += crossFactor * (nx * stone1.vy - ny * stone1.vx);
  stone2.w += crossFactor * (nx * stone2.vy - ny * stone2.vx);
  
  // Slight position adjustment to prevent stones from sticking
  const overlap = 2 * params.R - distance;
  stone1.x -= overlap * nx / 2;
  stone1.y -= overlap * ny / 2;
  stone2.x += overlap * nx / 2;
  stone2.y += overlap * ny / 2;
}

// Simulate motion for a single stone
function simulateStone(stone, p, duration, checkCollisions = true) {
  // Copy the stone's state to work with
  let s = stone.toState();
  const traj = [s];
  
  const I = 0.5 * p.m * p.R * p.R;
  const dN = (p.m * p.g) / p.segments;
  const phis = Array.from({ length: p.segments }, (_, i) => (2 * Math.PI * i) / p.segments);
  
  const N = Math.floor(duration / p.dt);
  for (let step = 0; step < N; step++) {
    if (Math.hypot(s.vx, s.vy) < p.vStop && Math.abs(s.w) < p.wStop) break;
    
    let Fx = 0, Fy = 0, tau = 0;
    
    for (let phi of phis) {
      const vlocx = s.vx - s.w * p.rBand * Math.sin(phi);
      const vlocy = s.vy + s.w * p.rBand * Math.cos(phi);
      const vmag = Math.hypot(vlocx, vlocy) || p.vEps;
      const mu = p.mu0 * (1 / Math.sqrt(vmag));
      const vhatx = vlocx / vmag;
      const vhaty = vlocy / vmag;
      const dFx = -(dN * mu) * vhatx;
      const dFy = -(dN * mu) * vhaty;
      Fx += dFx; Fy += dFy;
      tau += p.rBand * (Math.cos(phi) * dFy - Math.sin(phi) * dFx);
    }
    
    const Vh = unit(s.vx, s.vy, p.vEps);
    const Vperp = { x: -Vh.uy, y: Vh.ux };
    const vRot = Math.max(Math.abs(s.w) * p.rBand, p.vEps);
    const muP = p.alpha * (p.mu0) * (1 / Math.sqrt(vRot));
    const FpMag = p.m * p.g * muP;
    const sgnw = s.w > 0 ? 1 : (s.w < 0 ? -1 : 0);
    
    Fx += sgnw * FpMag * Vperp.x;
    Fy += sgnw * FpMag * Vperp.y;
    tau += -sgnw * FpMag * p.rBand;
    
    const ax = Fx / p.m;
    const ay = Fy / p.m;
    const alphaZ = tau / I;
    
    const vx = s.vx + p.dt * ax;
    const vy = s.vy + p.dt * ay;
    const w = s.w + p.dt * alphaZ;
    const x = s.x + p.dt * vx;
    const y = s.y + p.dt * vy;
    
    s = new State(s.t + p.dt, x, y, vx, vy, w);
    traj.push(s);
    
    // Update the stone's state for collision detection
    if (checkCollisions) {
      stone.fromState(s);
      
      // Stop if off the visible sheet
      if (stone.x > XMAX + 0.5 || stone.x < XMIN - 0.5 || Math.abs(stone.y) > HALF_W + 0.5) {
        stone.inPlay = false;
        break;
      }
    }
  }
  
  // Update the stone with final state
  stone.fromState(s);
  
  return traj;
}

// Main simulation function for all stones
function simulateAll(p, duration) {
  // Initialize trajectories object
  const trajectories = {};
  stones.forEach(stone => {
    trajectories[stone.id] = [];
  });
  
  let time = 0;
  const timeStep = p.dt; // Use the same timestep as the physics
  
  while (time < duration) {
    // Check if all stones have stopped
    const allStopped = stones.every(stone => 
      !stone.inPlay || (Math.hypot(stone.vx, stone.vy) < p.vStop && Math.abs(stone.w) < p.wStop)
    );
    
    if (allStopped) break;
    
    // Move each stone for this time step
    stones.forEach(stone => {
      if (!stone.inPlay) return;
      
      // Simulate a single timestep for this stone
      const stepTraj = simulateStone(stone, p, timeStep, false);
      
      // Record trajectory
      if (stepTraj.length > 0) {
        trajectories[stone.id].push(stepTraj[stepTraj.length - 1]);
      }
    });
    
    // Check for collisions between stones
    detectCollisions(stones, p);
    
    time += timeStep;
  }
  
  return trajectories;
}

/** Simulate with initial velocity vector toward the broom */
function simulateDraw(Vmag, omegaMag, turnStr, p, startPt, broomPt) {
  const dir = unit(broomPt.x - startPt.x, broomPt.y - startPt.y, p.vEps);
  const vx0 = Vmag * dir.ux;
  const vy0 = Vmag * dir.uy;
  const w0 = turnStr === "in" ? Math.abs(omegaMag) : -Math.abs(omegaMag);

  const I = 0.5 * p.m * p.R * p.R;
  const dN = (p.m * p.g) / p.segments;
  const phis = Array.from({ length: p.segments }, (_, i) => (2 * Math.PI * i) / p.segments);

  let s = new State(0, startPt.x, startPt.y, vx0, vy0, w0);
  const traj = [s];

  const N = Math.floor(p.tMax / p.dt);
  for (let step = 0; step < N; step++) {
    if (Math.hypot(s.vx, s.vy) < p.vStop && Math.abs(s.w) < p.wStop) break;

    let Fx = 0, Fy = 0, tau = 0;

    for (let phi of phis) {
      const vlocx = s.vx - s.w * p.rBand * Math.sin(phi);
      const vlocy = s.vy + s.w * p.rBand * Math.cos(phi);
      const vmag = Math.hypot(vlocx, vlocy) || p.vEps;
      const mu = p.mu0 * (1 / Math.sqrt(vmag));
      const vhatx = vlocx / vmag;
      const vhaty = vlocy / vmag;
      const dFx = -(dN * mu) * vhatx;
      const dFy = -(dN * mu) * vhaty;
      Fx += dFx; Fy += dFy;
      tau += p.rBand * (Math.cos(phi) * dFy - Math.sin(phi) * dFx);
    }

    const Vh = unit(s.vx, s.vy, p.vEps);
    const Vperp = { x: -Vh.uy, y: Vh.ux };
    const vRot = Math.max(Math.abs(s.w) * p.rBand, p.vEps);
    const muP = p.alpha * (p.mu0) * (1 / Math.sqrt(vRot));
    const FpMag = p.m * p.g * muP;
    const sgnw = s.w > 0 ? 1 : (s.w < 0 ? -1 : 0);

    Fx += sgnw * FpMag * Vperp.x;
    Fy += sgnw * FpMag * Vperp.y;
    tau += -sgnw * FpMag * p.rBand;

    const ax = Fx / p.m;
    const ay = Fy / p.m;
    const alphaZ = tau / I;

    const vx = s.vx + p.dt * ax;
    const vy = s.vy + p.dt * ay;
    const w  = s.w + p.dt * alphaZ;
    const x  = s.x + p.dt * vx;
    const y  = s.y + p.dt * vy;

    s = new State(s.t + p.dt, x, y, vx, vy, w);
    traj.push(s);

    // Stop if off the visible sheet horizontally
    if (x > XMAX + 0.5 || x < XMIN - 0.5 || Math.abs(y) > HALF_W + 0.5) break;
  }
  return traj;
}

/*** Run + animate ***/
let anim = null;
let lastTraj = [];
let selectedStoneId = null; // Currently selected stone for throwing
let currentTeam = 'red'; // Track current team ('red' or 'yellow')

// Add a function to update stone visuals on the sheet
function updateStoneDisplay() {
  // Remove existing stones
  svg.selectAll(".stone").remove();
  
  // Add stones from the array
  stones.forEach(stone => {
    svg.append("circle")
      .attr("class", "stone")
      .attr("id", `stone-${stone.id}`)
      .attr("r", 7)
      .attr("cx", xScale(stone.x))
      .attr("cy", yScale(stone.y))
      .style("fill", stone.team === 'red' ? "#e74c3c" : "#f1c40f") // Red or yellow team colors
      .style("stroke", "#111")
      .style("stroke-width", 1.5)
      .style("cursor", "pointer")
      .style("stroke-dasharray", selectedStoneId === stone.id ? "2,2" : "none") // Highlight selected stone
      .on("click", (event) => {
        // Select this stone for throwing
        selectedStoneId = stone.id;
        updateStoneDisplay(); // Update to show selection
      })
      .call(d3.drag()
        .on("drag", (event) => {
          // Allow dragging stones to position them
          stone.x = xScale.invert(event.x);
          stone.y = yScale.invert(event.y);
          d3.select(`#stone-${stone.id}`)
            .attr("cx", xScale(stone.x))
            .attr("cy", yScale(stone.y));
        })
      );
  });
}

// Function to run the multi-stone simulation
function runOnce() {
  const p = new Params();
  
  if (stones.length === 0) {
    // If no stones placed, add one at the starting position
    const newStone = new Stone(
      1,
      {x: start.x, y: start.y},
      {vx: 0, vy: 0},
      0,
      currentTeam
    );
    stones.push(newStone);
    selectedStoneId = newStone.id;
    updateStoneDisplay();
  }
  
  // Find the selected stone or use the first one
  const activeStoneIndex = selectedStoneId ? 
    stones.findIndex(s => s.id === selectedStoneId) : 
    stones.findIndex(s => s.team === currentTeam);
  
  if (activeStoneIndex === -1) {
    alert("Please select a stone to throw");
    return;
  }
  
  const activeStone = stones[activeStoneIndex];
  
  // Set velocity and spin for the selected stone
  const dir = unit(broomPos.x - activeStone.x, broomPos.y - activeStone.y, p.vEps);
  activeStone.vx = V0() * dir.ux;
  activeStone.vy = V0() * dir.uy;
  activeStone.w = turn() === "in" ? Math.abs(omega0()) : -Math.abs(omega0());
  
  // Clear previous paths
  svg.selectAll(".path").remove();
  
  // Run the multi-stone simulation
  const trajectories = simulateAll(p, p.tMax);
  
  // Draw paths for all stones that moved
  Object.entries(trajectories).forEach(([stoneId, traj]) => {
    if (traj.length > 1) {
      const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
      svg.append("path")
        .attr("class", "path")
        .attr("d", line(traj))
        .style("stroke", stones.find(s => s.id == stoneId).team === 'red' ? "#e74c3c55" : "#f1c40f55")
        .style("stroke-width", 2);
    }
  });
  
  // Display metrics for the active stone
  const stoneId = activeStone.id;
  const traj = trajectories[stoneId];
  
  if (traj && traj.length > 0) {
    const end = traj[traj.length - 1];
    mx.textContent = end.x.toFixed(2);
    my.textContent = end.y.toFixed(2);
    mt.textContent = end.t.toFixed(2);
    
    // Calculate hog-to-hog time if the stone crossed the far hog line
    let hogToHog = null;
    for (let i = 1; i < traj.length; i++) {
      if (traj[i-1].x <= FAR_HOG_X && traj[i].x >= FAR_HOG_X) {
        const t0 = traj[i-1], t1 = traj[i];
        const f = (FAR_HOG_X - t0.x) / (t1.x - t0.x);
        hogToHog = t0.t + f * (t1.t - t0.t);
        break;
      }
    }
    mhh.textContent = hogToHog !== null ? hogToHog.toFixed(2) : "—";
  } else {
    mx.textContent = my.textContent = mt.textContent = mhh.textContent = "—";
  }
  
  // Animate the stones
  animateStones(trajectories, p.dt);
  
  // Switch teams after throwing
  currentTeam = currentTeam === 'red' ? 'yellow' : 'red';
}

// Animation function for multiple stones
function animateStones(trajectories, dt) {
  stopAnim();
  
  // Find the maximum frame count across all trajectories
  let maxFrames = 0;
  Object.values(trajectories).forEach(traj => {
    maxFrames = Math.max(maxFrames, traj.length);
  });
  
  if (maxFrames === 0) return; // No trajectories to animate
  
  const stepMS = 1000 * dt; // one sim-step per frame
  let frame = 0;
  
  anim = d3.interval(() => {
    if (frame >= maxFrames) { 
      stopAnim();
      updateStoneDisplay(); // Ensure final positions are shown
      return; 
    }
    
    // Update each stone position
    Object.entries(trajectories).forEach(([stoneId, traj]) => {
      if (frame < traj.length) {
        const stoneElem = d3.select(`#stone-${stoneId}`);
        if (!stoneElem.empty()) {
          stoneElem
            .attr("cx", xScale(traj[frame].x))
            .attr("cy", yScale(traj[frame].y));
        }
      }
    });
    
    frame++;
  }, stepMS);
}

function stopAnim() { if (anim) { anim.stop(); anim = null; } }

function resetAll() {
  stopAnim();
  svg.selectAll(".path").remove();
  stones.length = 0; // Remove all stones
  updateStoneDisplay();
  mx.textContent = my.textContent = mt.textContent = mhh.textContent = "";
  currentTeam = 'red'; // Reset to first team
}

function clearStones() {
  stopAnim();
  svg.selectAll(".path").remove();
  stones.length = 0;
  updateStoneDisplay();
}

function exportCSV() {
  if (stones.length === 0) {
    alert("No stones to export data for.");
    return;
  }
  
  // Export all stone positions and states
  let csv = "stone_id,team,t_s,x_m,y_m,vx_mps,vy_mps,omega_radps\n";
  
  stones.forEach(stone => {
    csv += `${stone.id},${stone.team},${stone.t.toFixed(4)},${stone.x.toFixed(6)},${stone.y.toFixed(6)},${stone.vx.toFixed(6)},${stone.vy.toFixed(6)},${stone.w.toFixed(6)}\n`;
  });
  
  const blob = new Blob([csv], {type: "text/csv;charset=utf-8;"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = "stones.csv";
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// Generate a unique ID for stones
function generateStoneId() {
  return stones.length > 0 ? Math.max(...stones.map(s => s.id)) + 1 : 1;
}

// Function to add a new stone
function addStone(team) {
  // Position new stones in a reasonable location near start
  const offset = stones.length * 0.2; // Offset stones to avoid overlap
  const yPos = team === 'red' ? -0.2 - offset : 0.2 + offset;
  
  const newStone = new Stone(
    generateStoneId(),
    {x: start.x, y: yPos},
    {vx: 0, vy: 0},
    0,
    team
  );
  
  stones.push(newStone);
  selectedStoneId = newStone.id;
  updateStoneDisplay();
}

// Function to remove a selected stone
function removeSelectedStone() {
  if (selectedStoneId === null) {
    alert("Please select a stone to remove");
    return;
  }
  
  const index = stones.findIndex(s => s.id === selectedStoneId);
  if (index !== -1) {
    stones.splice(index, 1);
    selectedStoneId = stones.length > 0 ? stones[0].id : null;
    updateStoneDisplay();
  }
}

// Wire buttons
document.getElementById("throwBtn").addEventListener("click", runOnce);
document.getElementById("resetBtn").addEventListener("click", resetAll);
document.getElementById("csvBtn").addEventListener("click", exportCSV);
document.getElementById("stopBtn").addEventListener("click", stopAnim);

// Stone control buttons
document.getElementById("addRedBtn").addEventListener("click", () => addStone('red'));
document.getElementById("addYellowBtn").addEventListener("click", () => addStone('yellow'));
document.getElementById("removeStoneBtn").addEventListener("click", removeSelectedStone);
document.getElementById("clearStonesBtn").addEventListener("click", clearStones);

// Remove the original stone object and initialize the display
svg.selectAll(".stone").remove();
updateStoneDisplay();
</script>
</body>
</html>
