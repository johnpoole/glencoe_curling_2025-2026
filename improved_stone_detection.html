<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Improved Stone Detection</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        button { background: #007ACC; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px; }
        button:hover { background: #005a99; }
        .image-display { border: 2px solid #ddd; border-radius: 5px; margin: 10px 0; }
        .results { background: #f8f9fa; padding: 15px; border-radius: 5px; margin-top: 10px; white-space: pre-wrap; font-family: monospace; }
        .detection-overlay { position: relative; display: inline-block; }
        canvas { border: 1px solid #ccc; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Improved Stone Detection (Calibrated)</h1>
        <p>Updated detection algorithm based on your corrections!</p>
        
        <input type="file" id="imageInput" accept="image/*">
        <button id="detectBtn" disabled>Detect Stones (Improved)</button>
        <button id="clearBtn">Clear</button>
        
        <div id="imageContainer" style="display: none;">
            <h3>Detection Results</h3>
            <div class="detection-overlay">
                <canvas id="detectionCanvas"></canvas>
            </div>
        </div>
        
        <div id="results" class="results">Select an image to analyze...</div>
    </div>

    <script>
        class ImprovedStoneDetection {
            constructor() {
                this.uploadedImage = null;
                this.detectionCanvas = document.getElementById('detectionCanvas');
                this.detectionCtx = this.detectionCanvas.getContext('2d');
            }

            async loadImage(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = reject;
                        img.src = e.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            detectIceRegion(pixels, width, height) {
                // Same ice detection as before
                const rowBrightness = new Float32Array(height);
                for (let y = 0; y < height; y++) {
                    let sum = 0;
                    let count = 0;
                    for (let x = 0; x < width; x += 10) {
                        const idx = (y * width + x) * 4;
                        const r = pixels[idx];
                        const g = pixels[idx + 1];
                        const b = pixels[idx + 2];
                        const bright = 0.299 * r + 0.587 * g + 0.114 * b;
                        sum += bright;
                        count++;
                    }
                    rowBrightness[y] = sum / Math.max(1, count);
                }

                const smooth = new Float32Array(height);
                const window = 25;
                for (let y = 0; y < height; y++) {
                    let s = 0, c = 0;
                    for (let k = Math.max(0, y - window); k <= Math.min(height - 1, y + window); k++) {
                        s += rowBrightness[k];
                        c++;
                    }
                    smooth[y] = s / c;
                }

                const threshold = smooth.reduce((a, b) => a + b) / smooth.length * 1.05;
                let top = 0, bottom = height - 1;
                
                for (let y = 0; y < height; y++) {
                    if (smooth[y] > threshold) { top = y; break; }
                }
                for (let y = height - 1; y >= 0; y--) {
                    if (smooth[y] > threshold) { bottom = y; break; }
                }

                return { x: 0, y: top, width: width, height: bottom - top };
            }

            detectColoredRegions(pixels, width, height, color) {
                const regions = [];
                const visited = new Set();
                
                // IMPROVED: More sensitive thresholds based on your low-confidence detections
                const isTargetColor = (r, g, b) => {
                    if (color === 'red') {
                        return r > 120 && r > g + 20 && r > b + 20; // Lowered from 130
                    } else if (color === 'blue') {
                        return b > 95 && b > r + 15 && b > g + 15; // Lowered from 100
                    }
                    return false;
                };

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const key = y * width + x;
                        if (visited.has(key)) continue;

                        const idx = key * 4;
                        const r = pixels[idx];
                        const g = pixels[idx + 1];
                        const b = pixels[idx + 2];

                        if (!isTargetColor(r, g, b)) continue;

                        // Flood fill to find connected region
                        const region = [];
                        const stack = [{ x, y }];
                        visited.add(key);

                        while (stack.length > 0) {
                            const { x: cx, y: cy } = stack.pop();
                            region.push({ x: cx, y: cy });

                            // Check 4-connected neighbors
                            for (const [dx, dy] of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {
                                const nx = cx + dx;
                                const ny = cy + dy;
                                if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;

                                const nkey = ny * width + nx;
                                if (visited.has(nkey)) continue;

                                const nidx = nkey * 4;
                                const nr = pixels[nidx];
                                const ng = pixels[nidx + 1];
                                const nb = pixels[nidx + 2];

                                if (isTargetColor(nr, ng, nb)) {
                                    visited.add(nkey);
                                    stack.push({ x: nx, y: ny });
                                }
                            }
                        }

                        // IMPROVED: Much lower minimum size based on your data
                        if (region.length >= 6) { // Was probably 15+
                            regions.push(region);
                        }
                    }
                }

                return regions;
            }

            groupRegionsIntoStones(regions, team) {
                if (regions.length === 0) return [];

                // Calculate center of each region
                const centers = regions.map(region => {
                    const sumX = region.reduce((sum, p) => sum + p.x, 0);
                    const sumY = region.reduce((sum, p) => sum + p.y, 0);
                    return {
                        x: sumX / region.length,
                        y: sumY / region.length,
                        pixelCount: region.length,
                        pixels: region,
                        team: team
                    };
                });

                // IMPROVED: Much larger clustering radius based on analysis (371px)
                const CLUSTER_RADIUS = 200; // Conservative value
                const stoneGroups = [];

                for (const center of centers) {
                    let merged = false;
                    for (const group of stoneGroups) {
                        const dist = Math.sqrt((center.x - group.x) ** 2 + (center.y - group.y) ** 2);
                        if (dist < CLUSTER_RADIUS) {
                            // Merge with existing group
                            const totalPixels = group.pixelCount + center.pixelCount;
                            group.x = (group.x * group.pixelCount + center.x * center.pixelCount) / totalPixels;
                            group.y = (group.y * group.pixelCount + center.y * center.pixelCount) / totalPixels;
                            group.pixelCount = totalPixels;
                            group.pixels = [...group.pixels, ...center.pixels];
                            merged = true;
                            break;
                        }
                    }
                    if (!merged) {
                        stoneGroups.push(center);
                    }
                }

                return stoneGroups.sort((a, b) => b.pixelCount - a.pixelCount);
            }

            async analyzeImage() {
                if (!this.uploadedImage) throw new Error('No image loaded');

                // Set up canvas
                const maxDisplayWidth = 800;
                const scale = Math.min(maxDisplayWidth / this.uploadedImage.width, 1);
                
                this.detectionCanvas.width = this.uploadedImage.width * scale;
                this.detectionCanvas.height = this.uploadedImage.height * scale;
                
                this.detectionCtx.drawImage(this.uploadedImage, 0, 0, this.detectionCanvas.width, this.detectionCanvas.height);

                // Create full-res offscreen canvas
                const off = document.createElement('canvas');
                off.width = this.uploadedImage.width;
                off.height = this.uploadedImage.height;
                const offCtx = off.getContext('2d');
                offCtx.drawImage(this.uploadedImage, 0, 0);

                const fullImageData = offCtx.getImageData(0, 0, off.width, off.height);
                const crop = this.detectIceRegion(fullImageData.data, off.width, off.height);

                // Show crop region
                this.detectionCtx.strokeStyle = '#00FF00';
                this.detectionCtx.lineWidth = 3;
                this.detectionCtx.strokeRect(
                    crop.x * scale, 
                    crop.y * scale, 
                    crop.width * scale, 
                    crop.height * scale
                );

                // Create cropped canvas
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = crop.width;
                cropCanvas.height = crop.height;
                const cropCtx = cropCanvas.getContext('2d');
                cropCtx.drawImage(off, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);

                // Process at full resolution to avoid losing small stones
                const procImageData = cropCtx.getImageData(0, 0, crop.width, crop.height);

                // Detect stones
                const redRegions = this.detectColoredRegions(procImageData.data, crop.width, crop.height, 'red');
                const blueRegions = this.detectColoredRegions(procImageData.data, crop.width, crop.height, 'blue');

                const redStones = this.groupRegionsIntoStones(redRegions, 'red');
                const blueStones = this.groupRegionsIntoStones(blueRegions, 'blue');

                // Get top candidates
                const finalRedStones = redStones.slice(0, 2);
                const finalBlueStones = blueStones.slice(0, 1);

                // Draw detected stones
                [...finalRedStones, ...finalBlueStones].forEach(stone => {
                    const origX = (stone.x + crop.x) * scale;
                    const origY = (stone.y + crop.y) * scale;
                    
                    const color = stone.team === 'red' ? '#FF0000' : '#0000FF';
                    const radius = 25;

                    this.detectionCtx.fillStyle = color + '80';
                    this.detectionCtx.strokeStyle = color;
                    this.detectionCtx.lineWidth = 4;
                    this.detectionCtx.beginPath();
                    this.detectionCtx.arc(origX, origY, radius, 0, 2 * Math.PI);
                    this.detectionCtx.fill();
                    this.detectionCtx.stroke();

                    this.detectionCtx.fillStyle = 'white';
                    this.detectionCtx.font = 'bold 16px Arial';
                    this.detectionCtx.textAlign = 'center';
                    this.detectionCtx.fillText(stone.team[0].toUpperCase(), origX, origY + 5);
                    
                    // Add confidence label
                    this.detectionCtx.font = 'bold 12px Arial';
                    this.detectionCtx.fillText(stone.pixelCount, origX, origY - 30);
                });

                return {
                    stones: [...finalRedStones, ...finalBlueStones],
                    debug: {
                        crop,
                        redCandidates: redRegions.length,
                        blueCandidates: blueRegions.length,
                        finalRed: finalRedStones.length,
                        finalBlue: finalBlueStones.length
                    }
                };
            }
        }

        // UI handlers
        const imageInput = document.getElementById('imageInput');
        const detectBtn = document.getElementById('detectBtn');
        const clearBtn = document.getElementById('clearBtn');
        const imageContainer = document.getElementById('imageContainer');
        const results = document.getElementById('results');
        const detector = new ImprovedStoneDetection();

        imageInput.addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (file) {
                try {
                    detector.uploadedImage = await detector.loadImage(file);
                    detectBtn.disabled = false;
                    results.textContent = `Image loaded: ${detector.uploadedImage.width}x${detector.uploadedImage.height}\nReady to analyze with IMPROVED detection...`;
                } catch (error) {
                    results.textContent = `Error loading image: ${error.message}`;
                }
            }
        });

        detectBtn.addEventListener('click', async function() {
            try {
                results.textContent = 'Running improved detection algorithm...';
                imageContainer.style.display = 'block';
                
                const analysis = await detector.analyzeImage();
                
                let output = 'üéØ IMPROVED STONE DETECTION RESULTS\n\n';
                output += 'ALGORITHM IMPROVEMENTS:\n';
                output += '‚úì Lowered color thresholds (red: 120, blue: 95)\n';
                output += '‚úì Reduced minimum pixel requirement to 6\n';
                output += '‚úì Increased clustering radius to 200px\n';
                output += '‚úì Processing at full resolution\n\n';
                
                output += `Detected ${analysis.stones.length} stones:\n\n`;
                
                analysis.stones.forEach((stone, i) => {
                    output += `${stone.team.toUpperCase()} stone ${i+1}:\n`;
                    output += `  Position: (${Math.round(stone.x)}, ${Math.round(stone.y)})\n`;
                    output += `  Confidence: ${stone.pixelCount} pixels\n\n`;
                });
                
                output += `üìä DETECTION STATS:\n`;
                output += `  Red candidates found: ${analysis.debug.redCandidates}\n`;
                output += `  Blue candidates found: ${analysis.debug.blueCandidates}\n`;
                output += `  Final stones: ${analysis.debug.finalRed} red + ${analysis.debug.finalBlue} blue\n\n`;
                
                output += `üîç VISUAL INDICATORS:\n`;
                output += `Green rectangle = ice region\n`;
                output += `Large circles = detected stones\n`;
                output += `Numbers = confidence (pixel count)`;
                
                results.textContent = output;
                
            } catch (error) {
                results.textContent = `Detection failed: ${error.message}`;
                imageContainer.style.display = 'none';
            }
        });

        clearBtn.addEventListener('click', function() {
            imageInput.value = '';
            detectBtn.disabled = true;
            imageContainer.style.display = 'none';
            results.textContent = 'Select an image to analyze...';
            detector.uploadedImage = null;
        });
    </script>
</body>
</html>