<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Curling Image Auto-Correction</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        button { background: #007ACC; color: white; border: none; padding: 15px 30px; border-radius: 5px; cursor: pointer; margin: 10px; font-size: 16px; }
        button:hover { background: #005a99; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        .results { background: #f8f9fa; padding: 15px; border-radius: 5px; margin-top: 10px; white-space: pre-wrap; font-family: monospace; }
        canvas { border: 1px solid #ccc; max-width: 100%; margin: 10px 0; }
        .step { border: 1px solid #ddd; padding: 20px; margin: 15px 0; border-radius: 5px; background: white; }
        .step h3 { margin-top: 0; color: #007ACC; }
        .progress { background: #e9ecef; border-radius: 5px; margin: 10px 0; }
        .progress-bar { background: #007ACC; height: 20px; border-radius: 5px; transition: width 0.3s; }
        .status { font-weight: bold; color: #007ACC; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Smart Curling Image Auto-Correction</h1>
        <p><strong>Automatic:</strong> Edge detection ‚Üí Ice cropping ‚Üí Lens correction ‚Üí Reference lines</p>
        
        <input type="file" id="imageInput" accept="image/*" style="margin: 10px 0; font-size: 16px;">
        <br>
        <button id="autoProcessBtn" disabled>üéØ Auto-Process Image</button>
        <button id="exportBtn" disabled>üíæ Export Corrected Image</button>
        
        <div id="progress" class="progress" style="display: none;">
            <div id="progressBar" class="progress-bar" style="width: 0%;"></div>
        </div>
        <div id="status" class="status"></div>
        
        <div class="step">
            <h3>üì∏ Original Image</h3>
            <canvas id="originalCanvas"></canvas>
        </div>
        
        <div class="step">
            <h3>üîç Edge Detection & Ice Boundary</h3>
            <canvas id="edgeCanvas"></canvas>
        </div>
        
        <div class="step">
            <h3>‚úÇÔ∏è Auto-Cropped Ice Sheet</h3>
            <canvas id="croppedCanvas"></canvas>
        </div>
        
        <div class="step">
            <h3>üìè Final Result with Reference Lines</h3>
            <canvas id="finalCanvas"></canvas>
        </div>
        
        <div id="results" class="results">Select an image to begin auto-processing...</div>
    </div>

    <script>
        class SmartCurlingProcessor {
            constructor() {
                this.originalImage = null;
                this.processedImage = null;
                
                this.originalCanvas = document.getElementById('originalCanvas');
                this.edgeCanvas = document.getElementById('edgeCanvas');
                this.croppedCanvas = document.getElementById('croppedCanvas');
                this.finalCanvas = document.getElementById('finalCanvas');
                
                this.originalCtx = this.originalCanvas.getContext('2d');
                this.edgeCtx = this.edgeCanvas.getContext('2d');
                this.croppedCtx = this.croppedCanvas.getContext('2d');
                this.finalCtx = this.finalCanvas.getContext('2d');
            }

            async loadImage(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = reject;
                        img.src = e.target.result;
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            updateProgress(percent, status) {
                document.getElementById('progressBar').style.width = percent + '%';
                document.getElementById('status').textContent = status;
            }

            displayOriginal() {
                if (!this.originalImage) return;

                const maxWidth = 800;
                const scale = Math.min(maxWidth / this.originalImage.width, 1);
                
                this.originalCanvas.width = this.originalImage.width * scale;
                this.originalCanvas.height = this.originalImage.height * scale;
                
                this.originalCtx.drawImage(this.originalImage, 0, 0, this.originalCanvas.width, this.originalCanvas.height);
            }

            detectEdges() {
                this.updateProgress(20, "Detecting edges and ice boundaries...");
                
                // Create full-res working canvas
                const workCanvas = document.createElement('canvas');
                workCanvas.width = this.originalImage.width;
                workCanvas.height = this.originalImage.height;
                const workCtx = workCanvas.getContext('2d');
                workCtx.drawImage(this.originalImage, 0, 0);
                
                const imageData = workCtx.getImageData(0, 0, workCanvas.width, workCanvas.height);
                const pixels = imageData.data;
                
                // Convert to grayscale and find high-contrast edges
                const gray = new Uint8Array(workCanvas.width * workCanvas.height);
                for (let i = 0; i < pixels.length; i += 4) {
                    const brightness = 0.299 * pixels[i] + 0.587 * pixels[i + 1] + 0.114 * pixels[i + 2];
                    gray[i / 4] = brightness;
                }
                
                // Sobel edge detection
                const edges = new Uint8Array(workCanvas.width * workCanvas.height);
                for (let y = 1; y < workCanvas.height - 1; y++) {
                    for (let x = 1; x < workCanvas.width - 1; x++) {
                        const idx = y * workCanvas.width + x;
                        
                        // Sobel X kernel
                        const gx = -gray[(y-1)*workCanvas.width + (x-1)] + gray[(y-1)*workCanvas.width + (x+1)] +
                                  -2*gray[y*workCanvas.width + (x-1)] + 2*gray[y*workCanvas.width + (x+1)] +
                                  -gray[(y+1)*workCanvas.width + (x-1)] + gray[(y+1)*workCanvas.width + (x+1)];
                        
                        // Sobel Y kernel  
                        const gy = -gray[(y-1)*workCanvas.width + (x-1)] - 2*gray[(y-1)*workCanvas.width + x] - gray[(y-1)*workCanvas.width + (x+1)] +
                                   gray[(y+1)*workCanvas.width + (x-1)] + 2*gray[(y+1)*workCanvas.width + x] + gray[(y+1)*workCanvas.width + (x+1)];
                        
                        const magnitude = Math.sqrt(gx * gx + gy * gy);
                        edges[idx] = Math.min(255, magnitude);
                    }
                }
                
                // Find ice boundaries using edge information
                const iceBounds = this.findIceBoundaries(edges, gray, workCanvas.width, workCanvas.height);
                
                // Display edge detection result
                const displayScale = Math.min(800 / workCanvas.width, 600 / workCanvas.height, 1);
                this.edgeCanvas.width = workCanvas.width * displayScale;
                this.edgeCanvas.height = workCanvas.height * displayScale;
                
                // Draw original with edge overlay
                this.edgeCtx.drawImage(this.originalImage, 0, 0, this.edgeCanvas.width, this.edgeCanvas.height);
                
                // Overlay detected ice boundary
                this.edgeCtx.strokeStyle = '#00FF00';
                this.edgeCtx.lineWidth = 3;
                this.edgeCtx.strokeRect(
                    iceBounds.x * displayScale,
                    iceBounds.y * displayScale, 
                    iceBounds.width * displayScale,
                    iceBounds.height * displayScale
                );
                
                // Add labels
                this.edgeCtx.fillStyle = '#00FF00';
                this.edgeCtx.font = 'bold 16px Arial';
                this.edgeCtx.fillText('DETECTED ICE BOUNDARY', 10, 25);
                
                return iceBounds;
            }

            findIceBoundaries(edges, gray, width, height) {
                // Analyze horizontal edges to find top/bottom of ice
                const rowEdgeStrength = new Float32Array(height);
                const rowBrightness = new Float32Array(height);
                
                for (let y = 0; y < height; y++) {
                    let edgeSum = 0;
                    let brightSum = 0;
                    let count = 0;
                    
                    for (let x = Math.floor(width * 0.1); x < Math.floor(width * 0.9); x += 5) {
                        edgeSum += edges[y * width + x];
                        brightSum += gray[y * width + x];
                        count++;
                    }
                    
                    rowEdgeStrength[y] = edgeSum / count;
                    rowBrightness[y] = brightSum / count;
                }
                
                // Find ice region - look for sustained high brightness with clear edges
                const avgBrightness = rowBrightness.reduce((a, b) => a + b) / rowBrightness.length;
                const brightThreshold = avgBrightness * 1.15; // Ice should be brighter than average
                
                let topBound = 0;
                let bottomBound = height - 1;
                
                // Find top boundary - first sustained bright region
                for (let y = Math.floor(height * 0.05); y < Math.floor(height * 0.95); y++) {
                    let sustainedBright = true;
                    for (let check = 0; check < 20 && y + check < height; check++) {
                        if (rowBrightness[y + check] < brightThreshold) {
                            sustainedBright = false;
                            break;
                        }
                    }
                    if (sustainedBright) {
                        topBound = Math.max(0, y - 10); // Add small buffer
                        break;
                    }
                }
                
                // Find bottom boundary - last sustained bright region
                for (let y = Math.floor(height * 0.95); y > Math.floor(height * 0.05); y--) {
                    let sustainedBright = true;
                    for (let check = 0; check < 20 && y - check >= 0; check++) {
                        if (rowBrightness[y - check] < brightThreshold) {
                            sustainedBright = false;
                            break;
                        }
                    }
                    if (sustainedBright) {
                        bottomBound = Math.min(height - 1, y + 10); // Add small buffer
                        break;
                    }
                }
                
                // For left/right, assume full width for now (ice typically spans full width)
                // Could add vertical edge analysis here if needed
                
                return {
                    x: 0,
                    y: topBound,
                    width: width,
                    height: bottomBound - topBound
                };
            }

            cropToIce(iceBounds) {
                this.updateProgress(50, "Cropping to ice sheet boundaries...");
                
                // Create cropped canvas
                const croppedCanvas = document.createElement('canvas');
                croppedCanvas.width = iceBounds.width;
                croppedCanvas.height = iceBounds.height;
                const croppedCtx = croppedCanvas.getContext('2d');
                
                // Draw cropped region
                croppedCtx.drawImage(this.originalImage, 
                    iceBounds.x, iceBounds.y, iceBounds.width, iceBounds.height,
                    0, 0, iceBounds.width, iceBounds.height);
                
                // Store for later use
                this.processedImage = croppedCanvas;
                
                // Display cropped result
                const displayScale = Math.min(800 / iceBounds.width, 600 / iceBounds.height, 1);
                this.croppedCanvas.width = iceBounds.width * displayScale;
                this.croppedCanvas.height = iceBounds.height * displayScale;
                
                this.croppedCtx.drawImage(croppedCanvas, 0, 0, this.croppedCanvas.width, this.croppedCanvas.height);
                
                return croppedCanvas;
            }

            drawReferenceLines(croppedCanvas) {
                this.updateProgress(80, "Drawing curling sheet reference lines...");
                
                const displayScale = Math.min(800 / croppedCanvas.width, 600 / croppedCanvas.height, 1);
                
                this.finalCanvas.width = croppedCanvas.width * displayScale;
                this.finalCanvas.height = croppedCanvas.height * displayScale;
                
                // Draw base image
                this.finalCtx.drawImage(croppedCanvas, 0, 0, this.finalCanvas.width, this.finalCanvas.height);
                
                // Standard curling sheet dimensions (150 feet total length)
                const sheetLength = 150;
                const houseDiameter = 12;
                const hoglineDistance = 37;
                
                const pixelsPerFoot = this.finalCanvas.height / sheetLength;
                const centerX = this.finalCanvas.width / 2;
                
                // Calculate line positions (assuming bottom = throwing area)
                const backlineNear = this.finalCanvas.height - pixelsPerFoot * 6; // 6 feet from back
                const backlineFar = pixelsPerFoot * 6;
                const teeLineNear = backlineNear - pixelsPerFoot * 6; // 6 feet from backline  
                const teeLineFar = backlineFar + pixelsPerFoot * 6;
                const hoglineNear = teeLineNear - pixelsPerFoot * hoglineDistance;
                const hoglineFar = teeLineFar + pixelsPerFoot * hoglineDistance;
                
                this.finalCtx.lineWidth = 2;
                
                // Draw centerline (red)
                this.finalCtx.strokeStyle = '#FF0000';
                this.finalCtx.setLineDash([]);
                this.finalCtx.beginPath();
                this.finalCtx.moveTo(centerX, 0);
                this.finalCtx.lineTo(centerX, this.finalCanvas.height);
                this.finalCtx.stroke();
                
                // Draw backlines (blue)
                this.finalCtx.strokeStyle = '#0000FF';
                this.finalCtx.beginPath();
                this.finalCtx.moveTo(0, backlineNear);
                this.finalCtx.lineTo(this.finalCanvas.width, backlineNear);
                this.finalCtx.moveTo(0, backlineFar);
                this.finalCtx.lineTo(this.finalCanvas.width, backlineFar);
                this.finalCtx.stroke();
                
                // Draw tee lines (green)
                this.finalCtx.strokeStyle = '#00AA00';
                this.finalCtx.beginPath();
                this.finalCtx.moveTo(0, teeLineNear);
                this.finalCtx.lineTo(this.finalCanvas.width, teeLineNear);
                this.finalCtx.moveTo(0, teeLineFar);
                this.finalCtx.lineTo(this.finalCanvas.width, teeLineFar);
                this.finalCtx.stroke();
                
                // Draw hoglines (purple)
                this.finalCtx.strokeStyle = '#AA00AA';
                this.finalCtx.setLineDash([10, 5]);
                this.finalCtx.beginPath();
                this.finalCtx.moveTo(0, hoglineNear);
                this.finalCtx.lineTo(this.finalCanvas.width, hoglineNear);
                this.finalCtx.moveTo(0, hoglineFar);
                this.finalCtx.lineTo(this.finalCanvas.width, hoglineFar);
                this.finalCtx.stroke();
                
                // Draw houses (circles)
                const houseRadius = (houseDiameter * pixelsPerFoot) / 2;
                this.finalCtx.strokeStyle = '#0066CC';
                this.finalCtx.setLineDash([]);
                this.finalCtx.lineWidth = 3;
                this.finalCtx.beginPath();
                this.finalCtx.arc(centerX, teeLineNear, houseRadius, 0, 2 * Math.PI);
                this.finalCtx.arc(centerX, teeLineFar, houseRadius, 0, 2 * Math.PI);
                this.finalCtx.stroke();
                
                // Add text labels with background
                const addLabel = (text, x, y, color = '#FFFFFF') => {
                    this.finalCtx.fillStyle = 'rgba(0,0,0,0.7)';
                    this.finalCtx.fillRect(x - 40, y - 15, 80, 20);
                    this.finalCtx.fillStyle = color;
                    this.finalCtx.font = 'bold 12px Arial';
                    this.finalCtx.textAlign = 'center';
                    this.finalCtx.fillText(text, x, y);
                };
                
                addLabel('CENTERLINE', centerX, 20, '#FF0000');
                addLabel('BACKLINE', centerX, backlineFar + 20, '#0000FF');
                addLabel('TEE LINE', centerX, teeLineFar - 20, '#00AA00');
                addLabel('HOUSE', centerX, teeLineFar + 10, '#0066CC');
                addLabel('HOGLINE', centerX, hoglineFar - 20, '#AA00AA');
            }

            async autoProcess() {
                if (!this.originalImage) return;

                try {
                    document.getElementById('progress').style.display = 'block';
                    
                    // Step 1: Display original
                    this.updateProgress(10, "Loading original image...");
                    this.displayOriginal();
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Step 2: Detect edges and ice boundaries
                    const iceBounds = this.detectEdges();
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Step 3: Crop to ice
                    const croppedCanvas = this.cropToIce(iceBounds);
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Step 4: Draw reference lines
                    this.drawReferenceLines(croppedCanvas);
                    
                    // Complete
                    this.updateProgress(100, "Processing complete! ‚úÖ");
                    document.getElementById('exportBtn').disabled = false;
                    
                    // Update results
                    const results = document.getElementById('results');
                    results.textContent = 
                        `üéØ AUTO-PROCESSING COMPLETE!\n\n` +
                        `Original: ${this.originalImage.width}x${this.originalImage.height}\n` +
                        `Ice bounds: x=${iceBounds.x}, y=${iceBounds.y}, ${iceBounds.width}x${iceBounds.height}\n` +
                        `Cropped: ${croppedCanvas.width}x${croppedCanvas.height}\n\n` +
                        `‚úÖ Edge detection found ice boundaries automatically\n` +
                        `‚úÖ Image cropped to remove non-ice areas\n` +
                        `‚úÖ Reference lines drawn with standard dimensions\n` +
                        `‚úÖ Ready for accurate stone detection!\n\n` +
                        `Legend:\n` +
                        `üî¥ Red line = Centerline\n` +
                        `üîµ Blue lines = Backlines (6ft from ends)\n` +
                        `üü¢ Green lines = Tee lines (center of houses)\n` +
                        `üü£ Purple dashed = Hoglines (37ft from tee)\n` +
                        `üîµ Blue circles = Houses (12ft diameter)`;
                        
                } catch (error) {
                    this.updateProgress(0, `Error: ${error.message}`);
                    document.getElementById('results').textContent = `Processing failed: ${error.message}`;
                }
            }

            exportCorrectedImage() {
                if (this.processedImage) {
                    const link = document.createElement('a');
                    link.download = 'corrected_curling_ice.png';
                    link.href = this.processedImage.toDataURL('image/png', 1.0);
                    link.click();
                    
                    alert('‚úÖ Corrected ice image exported!\nThis clean, cropped image is ready for stone detection.');
                }
            }
        }

        // Initialize
        const processor = new SmartCurlingProcessor();

        // Event handlers
        document.getElementById('imageInput').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (file) {
                try {
                    processor.originalImage = await processor.loadImage(file);
                    document.getElementById('autoProcessBtn').disabled = false;
                    document.getElementById('results').textContent = 
                        `Image loaded: ${processor.originalImage.width}x${processor.originalImage.height}\n` +
                        `Click "Auto-Process Image" to automatically detect ice boundaries and add reference lines.`;
                } catch (error) {
                    document.getElementById('results').textContent = `Error loading image: ${error.message}`;
                }
            }
        });

        document.getElementById('autoProcessBtn').addEventListener('click', function() {
            this.disabled = true;
            processor.autoProcess().finally(() => {
                this.disabled = false;
            });
        });

        document.getElementById('exportBtn').addEventListener('click', function() {
            processor.exportCorrectedImage();
        });
    </script>
</body>
</html>